<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:q,mm:v}=window,j=new q.Toolbar;j.attach(v);const we=j.render();we.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(we)})})()</script><script>((f,d,h,u)=>{const g=f();window.mm=g.Markmap.create("svg#mindmap",(d||g.deriveOptions)(u),h)})(()=>window.markmap,null,{"content":"Comparativa entre Métodos de Instancia y Métodos Estáticos","children":[{"content":"Métodos de Instancia","children":[{"content":"<strong>Descripción</strong>: Requieren que se cree una instancia de la clase antes de poder utilizar los métodos.","children":[],"payload":{"lines":"3,4"}},{"content":"Ventajas","children":[{"content":"<strong>Encapsulamiento y estado</strong>","children":[{"content":"Permiten que cada instancia de la clase mantenga su propio estado.","children":[],"payload":{"lines":"6,7"}},{"content":"Útil cuando necesitas que las diferentes instancias manejen datos distintos.","children":[],"payload":{"lines":"7,8"}}],"payload":{"lines":"5,8"}},{"content":"<strong>Herencia y polimorfismo</strong>","children":[{"content":"Permiten que las subclases sobrescriban métodos específicos para personalizar el comportamiento.","children":[],"payload":{"lines":"9,10"}},{"content":"Ventajoso en sistemas que utilizan herencia y polimorfismo.","children":[],"payload":{"lines":"10,11"}}],"payload":{"lines":"8,11"}},{"content":"<strong>Mayor flexibilidad</strong>","children":[{"content":"Adecuados cuando se necesita manejar dependencias o configuraciones individuales para cada instancia.","children":[],"payload":{"lines":"12,13"}}],"payload":{"lines":"11,13"}}],"payload":{"lines":"4,13"}},{"content":"Desventajas","children":[{"content":"<strong>Mayor complejidad en código simple</strong>","children":[{"content":"Si no es necesario mantener un estado, instanciar la clase puede agregar complejidad innecesaria.","children":[],"payload":{"lines":"15,16"}}],"payload":{"lines":"14,16"}},{"content":"<strong>Uso de memoria</strong>","children":[{"content":"Crear múltiples instancias puede consumir más memoria si las instancias manejan estados pesados.","children":[],"payload":{"lines":"17,18"}}],"payload":{"lines":"16,18"}},{"content":"<strong>Código más verboso</strong>","children":[{"content":"Requiere crear instancias explícitas de la clase, lo que introduce más código comparado con métodos estáticos.","children":[],"payload":{"lines":"19,20"}}],"payload":{"lines":"18,20"}}],"payload":{"lines":"13,20"}},{"content":"Casos de uso","children":[{"content":"<strong>Encapsulamiento de estado</strong>","children":[{"content":"Cuando la clase necesita mantener un estado interno que varía entre instancias.","children":[],"payload":{"lines":"22,23"}}],"payload":{"lines":"21,23"}},{"content":"<strong>Sistemas orientados a objetos</strong>","children":[{"content":"En sistemas que aprovechan la herencia y el polimorfismo.","children":[],"payload":{"lines":"24,25"}}],"payload":{"lines":"23,25"}},{"content":"<strong>Dependencias y configuraciones específicas</strong>","children":[{"content":"Si necesitas manejar configuraciones o dependencias que cambian entre diferentes instancias.","children":[],"payload":{"lines":"26,27"}}],"payload":{"lines":"25,27"}},{"content":"<strong>Extensibilidad</strong>","children":[{"content":"Cuando planeas extender la funcionalidad de la clase a través de subclases.","children":[],"payload":{"lines":"28,30"}}],"payload":{"lines":"27,30"}}],"payload":{"lines":"20,30"}}],"payload":{"lines":"2,3"}},{"content":"Métodos Estáticos","children":[{"content":"<strong>Descripción</strong>: Pertenecen a la clase misma, no a las instancias, y se pueden llamar directamente sin necesidad de instanciación.","children":[],"payload":{"lines":"31,32"}},{"content":"Ventajas","children":[{"content":"<strong>Simplificación del código</strong>","children":[{"content":"No necesitas crear instancias, lo que hace el código más conciso y fácil de leer.","children":[],"payload":{"lines":"34,35"}}],"payload":{"lines":"33,35"}},{"content":"<strong>Menor consumo de memoria</strong>","children":[{"content":"Al no crear instancias adicionales, se ahorra memoria al no mantener estado en objetos individuales.","children":[],"payload":{"lines":"36,37"}}],"payload":{"lines":"35,37"}},{"content":"<strong>Facilidad de uso en utilidades</strong>","children":[{"content":"Ideal para funciones de utilidad o servicios globales que no dependen de un estado compartido.","children":[],"payload":{"lines":"38,39"}}],"payload":{"lines":"37,39"}},{"content":"<strong>Accesibilidad global</strong>","children":[{"content":"Los métodos estáticos son accesibles desde cualquier parte del código sin preocuparse por instancias.","children":[],"payload":{"lines":"40,41"}}],"payload":{"lines":"39,41"}}],"payload":{"lines":"32,41"}},{"content":"Desventajas","children":[{"content":"<strong>Sin encapsulamiento de estado</strong>","children":[{"content":"No se puede mantener un estado específico por instancia, lo que limita su uso cuando se necesita manejar datos persistentes.","children":[],"payload":{"lines":"43,44"}}],"payload":{"lines":"42,44"}},{"content":"<strong>Limitaciones en herencia</strong>","children":[{"content":"Aunque es posible sobrescribir métodos estáticos en subclases, el comportamiento es diferente al de los métodos de instancia y puede llevar a problemas si no se maneja adecuadamente.","children":[],"payload":{"lines":"45,46"}}],"payload":{"lines":"44,46"}},{"content":"<strong>Falta de flexibilidad</strong>","children":[{"content":"Los métodos estáticos son menos flexibles cuando se trata de manejar dependencias o configuraciones que varían entre instancias.","children":[],"payload":{"lines":"47,48"}}],"payload":{"lines":"46,48"}}],"payload":{"lines":"41,48"}},{"content":"Casos de uso","children":[{"content":"<strong>Sin estado</strong>","children":[{"content":"Cuando la clase no necesita mantener un estado interno y todos los métodos son funcionales.","children":[],"payload":{"lines":"50,51"}}],"payload":{"lines":"49,51"}},{"content":"<strong>Utilidades y servicios globales</strong>","children":[{"content":"Para crear funciones reutilizables sin necesidad de instancias.","children":[],"payload":{"lines":"52,53"}}],"payload":{"lines":"51,53"}},{"content":"<strong>Optimización del código</strong>","children":[{"content":"Para reducir la complejidad del código y hacerlo accesible sin instanciación.","children":[],"payload":{"lines":"54,55"}}],"payload":{"lines":"53,55"}},{"content":"<strong>Rendimiento y memoria</strong>","children":[{"content":"En contextos donde se crean muchas instancias y se desea optimizar el rendimiento.","children":[],"payload":{"lines":"56,58"}}],"payload":{"lines":"55,58"}}],"payload":{"lines":"48,58"}}],"payload":{"lines":"30,31"}},{"content":"Comparativa de Uso según el Enfoque","children":[{"content":"\n<p data-lines=\"60,61\"><strong>Encapsulamiento de estado</strong></p>","children":[{"content":"Métodos de instancia: Ideal si necesitas que cada instancia mantenga su propio estado.","children":[],"payload":{"lines":"61,62"}},{"content":"Métodos estáticos: No se pueden mantener estados en métodos estáticos.","children":[],"payload":{"lines":"62,64"}}],"payload":{"lines":"60,64"}},{"content":"\n<p data-lines=\"64,65\"><strong>Herencia y polimorfismo</strong></p>","children":[{"content":"Métodos de instancia: Facilitan la herencia y el polimorfismo en programación orientada a objetos.","children":[],"payload":{"lines":"65,66"}},{"content":"Métodos estáticos: Limitado; los métodos estáticos no son ideales para herencia.","children":[],"payload":{"lines":"66,68"}}],"payload":{"lines":"64,68"}},{"content":"\n<p data-lines=\"68,69\"><strong>Complejidad de código</strong></p>","children":[{"content":"Métodos de instancia: Puede añadir complejidad innecesaria si no se requiere estado.","children":[],"payload":{"lines":"69,70"}},{"content":"Métodos estáticos: Simplifica el código al no requerir instanciación.","children":[],"payload":{"lines":"70,72"}}],"payload":{"lines":"68,72"}},{"content":"\n<p data-lines=\"72,73\"><strong>Consumo de memoria</strong></p>","children":[{"content":"Métodos de instancia: Más alto si se crean muchas instancias.","children":[],"payload":{"lines":"73,74"}},{"content":"Métodos estáticos: Más eficiente en memoria, ya que no hay instancias adicionales.","children":[],"payload":{"lines":"74,76"}}],"payload":{"lines":"72,76"}},{"content":"\n<p data-lines=\"76,77\"><strong>Reutilización global</strong></p>","children":[{"content":"Métodos de instancia: Requiere crear instancias en cada lugar donde se necesite.","children":[],"payload":{"lines":"77,78"}},{"content":"Métodos estáticos: Accesible desde cualquier parte del código sin instanciación.","children":[],"payload":{"lines":"78,80"}}],"payload":{"lines":"76,80"}},{"content":"\n<p data-lines=\"80,81\"><strong>Adecuación para utilidades</strong></p>","children":[{"content":"Métodos de instancia: Menos ideal para funciones de utilidad general.","children":[],"payload":{"lines":"81,82"}},{"content":"Métodos estáticos: Excelente para funciones de utilidad, ya que no dependen de estado.","children":[],"payload":{"lines":"82,83"}}],"payload":{"lines":"80,83"}}],"payload":{"lines":"58,59"}}],"payload":{"lines":"0,1"}},null)</script>
</body>
</html>
